---
import { siteConfig } from "../config";
import OpeningHours from "../components/OpeningHours.astro";

interface Props {
  openingHours: { days: string; hours: string; enabled: boolean };
}

const { openingHours } = Astro.props;
const { name, company } = siteConfig;
---

<section id="hero" class="hero-section">
  <div class="container">
    <div class="hero-content glass-card" id="foggy-hero">
      <canvas id="fog-canvas" class="fog-overlay"></canvas>
      <div class="hero-inner">
        <h1 class="fade-in-up">{name}</h1>
        <p class="hero-subtitle">
          Více než {company.yearsInBusiness} let působíme úspěšně v oblasti práce
          se sklem v České republice.
        </p>
        <p class="hero-description">
          Kvalitně a odborně provedené sklenářské práce tvoří jasnou známku naší
          profesionality.
        </p>

        <div class="hero-actions">
          <a href="#kontakt" class="btn btn-primary">Kontaktujte nás</a>
          <a href="#sluzby" class="btn btn-glass">Naše služby</a>
        </div>

        <div class="hero-hours">
          <OpeningHours
            days={openingHours.days}
            hours={openingHours.hours}
            enabled={openingHours.enabled}
          />
        </div>
      </div>
    </div>
  </div>
</section>

<script>
  const canvas = document.getElementById("fog-canvas") as HTMLCanvasElement;
  const ctx = canvas.getContext("2d");
  const hero = document.getElementById("foggy-hero");

  if (canvas && ctx && hero) {
    // Set canvas size
    const resizeCanvas = () => {
      canvas.width = hero.offsetWidth;
      canvas.height = hero.offsetHeight;
      drawFog();
    };

    // Generate water droplets for realistic condensation effect
    const generateDroplets = (count: number) => {
      const droplets = [];
      for (let i = 0; i < count; i++) {
        droplets.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 3 + 0.5,
          opacity: Math.random() * 0.3 + 0.2,
        });
      }
      return droplets;
    };

    // Generate water streaks running down
    const generateStreaks = (count: number) => {
      const streaks = [];
      for (let i = 0; i < count; i++) {
        streaks.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height * 0.3,
          length: Math.random() * 100 + 50,
          width: Math.random() * 2 + 0.5,
          opacity: Math.random() * 0.2 + 0.1,
        });
      }
      return streaks;
    };

    let droplets = generateDroplets(150);
    let streaks = generateStreaks(12);

    // Draw realistic fogged glass
    const drawFog = () => {
      // Base fog layer with gradient (darker at edges, lighter in center)
      const gradient = ctx.createRadialGradient(
        canvas.width / 2,
        canvas.height / 2,
        0,
        canvas.width / 2,
        canvas.height / 2,
        canvas.width * 0.7
      );
      gradient.addColorStop(0, "rgba(219, 226, 239, 0.5)");
      gradient.addColorStop(0.5, "rgba(219, 226, 239, 0.6)");
      gradient.addColorStop(1, "rgba(219, 226, 239, 0.65)");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Add noise/grain texture for realistic glass effect
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const noise = (Math.random() - 0.5) * 8;
        data[i] += noise; // R
        data[i + 1] += noise; // G
        data[i + 2] += noise; // B
      }
      ctx.putImageData(imageData, 0, 0);

      // Draw water droplets
      droplets.forEach((droplet) => {
        ctx.beginPath();
        ctx.arc(droplet.x, droplet.y, droplet.radius, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 255, 255, ${droplet.opacity * 0.6})`;
        ctx.fill();

        // Add highlight to droplet
        ctx.beginPath();
        ctx.arc(
          droplet.x - droplet.radius * 0.3,
          droplet.y - droplet.radius * 0.3,
          droplet.radius * 0.4,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = `rgba(255, 255, 255, ${droplet.opacity * 0.3})`;
        ctx.fill();
      });

      // Draw water streaks
      streaks.forEach((streak) => {
        ctx.beginPath();
        ctx.moveTo(streak.x, streak.y);
        ctx.lineTo(streak.x + Math.sin(streak.x) * 5, streak.y + streak.length);
        ctx.strokeStyle = `rgba(200, 210, 220, ${streak.opacity * 0.7})`;
        ctx.lineWidth = streak.width;
        ctx.stroke();
      });

      // Add frosted glass pattern (crystalline structures)
      for (let i = 0; i < 30; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        const size = Math.random() * 20 + 10;

        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(Math.random() * Math.PI);
        ctx.strokeStyle = `rgba(255, 255, 255, ${Math.random() * 0.05})`;
        ctx.lineWidth = 0.5;

        // Draw crystalline pattern
        for (let j = 0; j < 6; j++) {
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(
            size * Math.cos((j * Math.PI) / 3),
            size * Math.sin((j * Math.PI) / 3)
          );
          ctx.stroke();
        }
        ctx.restore();
      }
    };

    // Clear fog on mouse move with realistic wipe effect
    let clearRadius = 150;

    const clearFog = (x: number, y: number) => {
      ctx.globalCompositeOperation = "destination-out";

      // Multiple passes for softer, more realistic clearing
      for (let i = 0; i < 3; i++) {
        const radius = clearRadius * (1 - i * 0.2);
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        gradient.addColorStop(0, "rgba(0, 0, 0, 0.8)");
        gradient.addColorStop(0.4, "rgba(0, 0, 0, 0.4)");
        gradient.addColorStop(1, "rgba(0, 0, 0, 0)");

        ctx.fillStyle = gradient;
        ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
      }

      ctx.globalCompositeOperation = "source-over";

      // Remove droplets in cleared area
      droplets = droplets.filter((droplet) => {
        const distance = Math.sqrt((droplet.x - x) ** 2 + (droplet.y - y) ** 2);
        return distance > clearRadius;
      });

      // Remove streaks in cleared area
      streaks = streaks.filter((streak) => {
        const distance = Math.sqrt((streak.x - x) ** 2 + (streak.y - y) ** 2);
        return distance > clearRadius * 0.7;
      });
    };

    hero.addEventListener("mousemove", (e) => {
      const rect = hero.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      clearFog(x, y);
    });

    // Touch support for mobile - both scroll and brush work
    hero.addEventListener("touchmove", (e) => {
      // Always clear fog where finger is, don't prevent scroll
      const rect = hero.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      clearFog(x, y);
    }, { passive: true });

    // Initialize
    resizeCanvas();
    
    let resizeTimeout: number;
    window.addEventListener("resize", () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = window.setTimeout(() => {
        canvas.width = hero.offsetWidth;
        canvas.height = hero.offsetHeight;
        // Don't redraw fog - keep the cleared state
      }, 250);
    });
  }
</script>
